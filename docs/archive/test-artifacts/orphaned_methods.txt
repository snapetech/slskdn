    public ActionResult<AdversarialOptions> GetAdversarialSettings()
    {
        if (_adversarialOptions == null)
        {
            return NotFound("Adversarial features are not configured");
        }

        return Ok(_adversarialOptions);
    }

    [HttpGet("tor/status")]
    public ActionResult<AnonymityTransportStatus> GetTorStatus()
    {
        var torTransport = _transportSelector?.GetTorTransport();
        if (torTransport == null)
        {
            return NotFound("Tor transport is not configured or available");
        }

        var status = torTransport.GetStatus();
        return Ok(status);
    }

    [HttpPost("tor/test")]
    public async Task<ActionResult<AnonymityTransportStatus>> TestTorConnectivity()
    {
        var torTransport = _transportSelector?.GetTorTransport();
        if (torTransport == null)
        {
            return NotFound("Tor transport is not configured or available");
        }

        try
        {
            await torTransport.IsAvailableAsync();
            var status = torTransport.GetStatus();
            return Ok(status);
        }
        catch (Exception ex)
        {
            return StatusCode(500, $"Tor connectivity test failed: {ex.Message}");
        }
    }

    [HttpPut("adversarial")]
    public ActionResult UpdateAdversarialSettings([FromBody] AdversarialOptions settings)
    {
        // NOTE: In a real implementation, this would persist the settings
        // For now, just validate the input
        if (settings == null)
        {
            return BadRequest("Settings cannot be null");
        }

        // Basic validation
        if (settings.Privacy?.Padding?.BucketSizes != null &&
            settings.Privacy.Padding.BucketSizes.Any(size => size <= 0))
        {
            return BadRequest("Bucket sizes must be positive");
        }

        // TODO: Implement persistence and runtime configuration updates
        return Ok(new { message = "Adversarial settings updated (persistence not yet implemented)" });
    }

    [HttpGet("adversarial/stats")]
    public ActionResult<AdversarialStats> GetAdversarialStats()
    {
        return Ok(new AdversarialStats
        {
            Enabled = _adversarialOptions?.Enabled ?? false,
            Profile = _adversarialOptions?.Profile ?? AdversarialProfile.Disabled,
            PrivacyEnabled = _adversarialOptions?.Privacy?.Enabled ?? false,
            AnonymityEnabled = _adversarialOptions?.Anonymity?.Enabled ?? false,
            TransportEnabled = _adversarialOptions?.Transport?.Enabled ?? false,
            OnionRoutingEnabled = _adversarialOptions?.OnionRouting?.Enabled ?? false,
            CensorshipResistanceEnabled = _adversarialOptions?.CensorshipResistance?.Enabled ?? false,
            PlausibleDeniabilityEnabled = _adversarialOptions?.PlausibleDeniability?.Enabled ?? false,
        });
    }

    [HttpGet("transports/status")]
    public ActionResult<TransportSelectorStatus> GetTransportStatus()
    {
        if (_transportSelector == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Transport selector not available");
        }

        return Ok(_transportSelector.GetSelectorStatus());
    }

    [HttpGet("transports")]
    public ActionResult<Dictionary<AnonymityTransportType, AnonymityTransportStatus>> GetAllTransportStatuses()
    {
        if (_transportSelector == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Transport selector not available");
        }

        return Ok(_transportSelector.GetAllStatuses());
    }

    [HttpPost("transports/test")]
    public async Task<ActionResult> TestTransportConnectivity()
    {
        if (_transportSelector == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Transport selector not available");
        }

        try
        {
            await _transportSelector.TestConnectivityAsync();
            return Ok();
        }
        catch (Exception ex)
        {
            return StatusCode((int)HttpStatusCode.InternalServerError, $"Connectivity test failed: {ex.Message}");
        }
    }

    [HttpGet("circuits/stats")]
    public ActionResult<CircuitStatistics> GetCircuitStats()
    {
        if (_circuitBuilder == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Circuit builder not available");
        }

        return Ok(_circuitBuilder.GetStatistics());
    }

    [HttpGet("circuits")]
    public ActionResult<List<CircuitInfo>> GetActiveCircuits()
    {
        if (_circuitBuilder == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Circuit builder not available");
        }

        var circuits = _circuitBuilder.GetActiveCircuits();
        return Ok(circuits.Select(c => c.GetInfo()).ToList());
    }

    [HttpPost("circuits")]
    public async Task<ActionResult<CircuitInfo>> BuildCircuit([FromBody] BuildCircuitRequest request)
    {
        if (_circuitBuilder == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Circuit builder not available");
        }

        try
        {
            var circuit = await _circuitBuilder.BuildCircuitAsync(
                request.TargetPeerId,
                request.CircuitLength ?? 3);

            return Ok(circuit.GetInfo());
        }
        catch (Exception ex)
        {
            return StatusCode((int)HttpStatusCode.BadRequest, $"Circuit building failed: {ex.Message}");
        }
    }

    [HttpDelete("circuits/{circuitId}")]
    public ActionResult DestroyCircuit(string circuitId)
    {
        if (_circuitBuilder == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Circuit builder not available");
        }

        _circuitBuilder.DestroyCircuit(circuitId);
        return Ok();
    }

    [HttpGet("peers/stats")]
    public ActionResult<PeerStatistics> GetPeerStats()
    {
        if (_peerManager == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Peer manager not available");
        }

        return Ok(_peerManager.GetStatistics());
    }

    [HttpGet("peers")]
    public async Task<ActionResult<List<PeerInfo>>> GetPeers()
    {
        if (_peerManager == null)
        {
            return StatusCode((int)HttpStatusCode.ServiceUnavailable, "Peer manager not available");
        }

        var peers = await _peerManager.GetAvailablePeersAsync();
        return Ok(peers.Select(p => new PeerInfo
        {
            PeerId = p.PeerId,
            Addresses = p.Addresses.Select(a => a.ToString()).ToList(),
            LastSeen = p.LastSeen,
            TrustScore = p.TrustScore,
            LatencyMs = p.LatencyMs,
            BandwidthMbps = p.BandwidthMbps,
            SupportsOnionRouting = p.SupportsOnionRouting,
            Version = p.Version,
            QualityScore = p.GetQualityScore()
        }).ToList());
    }

/// <summary>
/// Request to ban an IP.
/// </summary>
    public required string IpAddress { get; set; }

    public string? Reason { get; set; }

    public int? Duration { get; set; }

    public bool Permanent { get; set; }

/// <summary>
/// Request to ban a username.
/// </summary>
    public required string Username { get; set; }

    public string? Reason { get; set; }

    public int? Duration { get; set; }

    public bool Permanent { get; set; }

/// <summary>
/// Request to set reputation.
/// </summary>
    public required int Score { get; set; }

    public string? Reason { get; set; }

/// <summary>
/// Request to set trust tier.
/// </summary>
    public required string Tier { get; set; }

    public string? Reason { get; set; }

/// <summary>
/// Adversarial features statistics.
/// </summary>
    public bool Enabled { get; set; }

    public AdversarialProfile Profile { get; set; }

    public bool PrivacyEnabled { get; set; }

    public bool AnonymityEnabled { get; set; }

    public bool TransportEnabled { get; set; }

    public bool OnionRoutingEnabled { get; set; }

    public bool CensorshipResistanceEnabled { get; set; }

    public bool PlausibleDeniabilityEnabled { get; set; }

/// <summary>
/// Request to build a new circuit.
/// </summary>
    public required string TargetPeerId { get; set; }

    public int? CircuitLength { get; set; }

/// <summary>
/// Information about a mesh peer.
/// </summary>
    public string PeerId { get; set; } = string.Empty;

    public List<string> Addresses { get; set; } = new();

    public DateTimeOffset LastSeen { get; set; }

    public double TrustScore { get; set; }

    public int LatencyMs { get; set; }

    public double BandwidthMbps { get; set; }

    public bool SupportsOnionRouting { get; set; }

    public string Version { get; set; } = string.Empty;

    public double QualityScore { get; set; }
